#### JDK JRE JVM

* JDK：Java Development Kit 开发工具包，面向程序开发者，提供了编译运行程序Java程序的各种工具包，包括编译器、JRE及常用库类，是JAVA核心。
* JRE：Java RunTime Environment 运行时环境，面向程序使用者。它是运行Java程序的必要环境，包括JVM、核心类库、核心配置工具。
* JVM：Java Virtual Mechinal,Java虚拟机。它负责解释执行字节码文件，是Java实现跨平台的核心。
* JDK包含JRE，JRE包含JVM。
* **使用JDK开发了JAVA程序后，通过JDK中的编译器将java源程序编译成字节码文件，在JRE上运行这些字节码文件，用JVM解析这些字节码文件，得到操作系统可以识别的机器语言进行执行操作。**

#### JVM内存结构

<img src="C:\Users\JH\AppData\Roaming\Typora\typora-user-images\image-20220623130314768.png" alt="image-20220623130314768"  />

jvm将虚拟机分为5大区域，程序计数器、虚拟机栈、本地方法栈、java堆、元空间;

**程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭。**

####  程序计数器

* 程序计数器是一块很小的内存空间，可以当作当前线程所执行的行号指示器。唯一在虚拟机中没有规定内存溢出情况的区域。

* 随线程而生，随线程而灭
* 不需要GC回收

#### 虚拟机栈

* 线程私有（每个线程里都有自己的，所以私有）
* 有个方法就创建一个栈帧，局部变量中的基本类型可以直接放入栈帧中的局部变量表中，引用类型(String User)就会指向堆里的引用对象，局部变量名、变量名所指向的值都存放到堆上的。
* 方法执行入虚拟机栈，方法执行完出虚拟机栈；（先进后出）
* 栈深度大于虚拟机所允许StackOverflowError （递归的时候会出现这个错误）
* 栈无法申请空间OutOfMemoryError 
* 栈随线程而生，随线程而灭
* 不需要GC回收
* Tips:加载一个class类的时候，是加载到元空间里的，然后元空间类的常量值放到堆区里的

#### 本地方法栈

* 区别于虚拟机栈为native提供服务的
* 栈随线程而生，随线程而灭
* 不需要GC回收

#### 堆

**堆的定义**

​		堆是用来存放对象的内存空间，几乎所有的对象都存储在堆中。

**堆的特点**

- 线程共享，整个 Java 虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java 虚拟机栈、本地方法栈都是一个线程对应一个。
- 在虚拟机启动时创建。
- 内存中最大的区域
- 是GC垃圾回收的主要场所。
- 进一步可分为：新生代（Eden 区：`From Survior`，`To Survivor`默认8：1：1）、老年代（70%）。
- Xmx、Xms调整堆内存
- OutOfMemeory OOM报错

不同的区域存放不同生命周期的对象，这样可以根据不同的区域使用不同的垃圾回收算法，更具有针对性。

​		堆的大小既可以固定也可以扩展，但对于主流的虚拟机，堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已无法再扩展时，就抛出 OutOfMemoryError 异常。

> Java 堆所使用的内存不需要保证是连续的。而由于堆是被所有线程共享的，所以对它的访问需要注意同步问题，方法和对应的属性都需要保证一致性。

#### 元空间（方法区/永久代）

* 存储被加载的类信息/常量/静态变量/常量池/即时编译后的代码的数据；
* 是线程共享的内存区域；
* 采用的是本地内存；内存不足时会发生内存溢出。
* 很少有GC垃圾收集；

#### 分配内存

对象所需内存大小在类加载完成后便可完全确定，分配空间的任务实际上等于把一块确定大小的内存块从 Java 堆中划分出来。  

![image-20220704135939583](C:\Users\JH\AppData\Roaming\Typora\typora-user-images\image-20220704135939583.png)

**指针碰撞**：对象所需内存大小在类加载完成后便可完全确定，分配空间的任务实际上等于把一块确定大小的内存块从 Java 堆中划分出来。  

**空闲列表**：如果 Java 堆内存不规整，虚拟机必须维护一个列表记录哪些内存可用，在分配时从列表中找到一块足够大的空间划分给对象并更新列表记录。选择哪种分配方式由堆是否规整决定，堆是否规整由垃圾收集器是否有空间压缩能力决定。使用Serial、ParNew 等收集器时，系统采用指针碰撞；使用 CMS 这种基于清除算法的垃圾收集器时，采用空间列表。  

对象创建十分频繁，即使修改一个指针的位置在并发下也不是线程安全的，可能正给对象 A 分配内存，指针还没来得及修改，对象 B 又使用了指针来分配内存。  

解决方法：

* ① CAS 加失败重试保证更新原子性。  
* ② 把内存分配按线程划分在不同空间，即每个线程在Java 堆中预先分配一小块内存，叫做本地线程分配缓冲 TLAB，哪个线程要分配内存就在对应的 TLAB分配，TLAB 用完了再进行同步。 现在一般采用TLAB。通过TLAB (Thread Local Allocation Buffer)， 是在Hotspot1.6引入的新技术。在线程启动时，在堆的Eden区域申请一块指定大小的内存，线程私有，如果线程内需要创建对象，则在此区域内创建,避免并发,提升性能。

![image-20220623222632029](C:\Users\JH\AppData\Roaming\Typora\typora-user-images\image-20220623222632029.png)

#### 堆内存的溢出

堆用于存储对象实例，只要不断创建对象并保证 GC Roots 到对象有可达路径避免垃圾回收，随着对象数量的增加，总容量触及最大堆容量后就会 OOM，例如在 while 死循环中一直 new 创建实例。堆 OOM 是实际应用中最常见的 OOM，处理方法是通过内存映像分析工具对 Dump 出的堆转储快照分析，确认内存中导致 OOM 的对象是否必要，分清到底是内存泄漏还是内存溢出。  

#### 判断对象是否是垃圾
引用计数：在对象中添加一个引用计数器，如果被引用计数器加 1，引用失效时计数器减 1，如果计数器为 0 则被标记为垃圾。原理简单，效率高，但是在 Java 中很少使用，因为存在对象间循环引用的问题，导致计数器无法清零。
可达性分析：主流语言的内存管理都使用可达性分析判断对象是否存活。基本思路是通过一系列称为GC Roots 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程走过的路径称为引用链，如果某个对象到 GC Roots 没有任何引用链相连，则会被标记为垃圾。可作为 GC Roots的对象包括虚拟机栈和本地方法栈中引用的对象、类静态属性引用的对象、常量引用的对象。  

#### Java 的引用类型
JDK1.2 后对引用进行了扩充，按强度分为四种：

* 强引用： 最常见的引用，例如 Object obj = new Object() 就属于强引用。只要对象有强引用指向且 GC Roots 可达，在内存回收时即使濒临内存耗尽也不会被回收。

* 软引用： 弱于强引用，描述非必需对象。在系统将发生内存溢出前，会把软引用关联的对象加入回收范围以获得更多内存空间。**用来缓存服务器中间计算结果及不需要实时保存的用户行为等。SoftReference软引用，内存不够了强引用来了就解决掉软引用。（备用和缓存）**

* 弱引用： 弱于软引用，描述非必需对象。弱引用关联的对象只能生存到下次 YGC 前，当垃圾收集器开始工作时无论当前内存是否足够都会回收只被弱引用关联的对象。垃圾回收器看到弱引用直接清理弱引用，ThreadLocal里经常用到。保证上下文同一个对象，如果不用弱引用的话key变成强引用，t1设为null，引用没法断，因为还有个引用指向ThreadLocal。**弱引用还用在weakashMap里防止泄漏**。
  
  <img src="C:\Users\JH\AppData\Roaming\Typora\typora-user-images\image-20220629215742252.png" alt="image-20220629215742252" style="zoom:67%;" />
  
* 虚引用： 最弱的引用，定义完成后无法通过该引用获取对象。唯一目的就是为了能在对象被回收时收到一个系统通知。虚引用必须与引用队列联合使用，**垃圾回收时如果出现虚引用，就会在回收对象前把这个虚引用加入引用队列  ，通知一下垃圾回收器。**
  **垃圾回收器对象回收不了直接内核内存，此时需要虚引用指向这个对象，回收放到队列，对这个队列特殊处理。**

#### GC算法

* 标记-清除算法
  分为标记和清除阶段，首先从每个 GC Roots 出发依次标记有引用关系的对象，最后清除没有标记的对象。
  
  * 执行效率不稳定，如果堆包含大量对象且大部分需要回收，必须进行大量标记清除，导致效率随对象数量增长而降低。
  * 存在内存空间碎片化问题，会产生大量不连续的内存碎片。
  * 导致以后需要分配大对象时容易触发 Full GC  。
  
* 标记-复制算法
  为了解决内存碎片问题，将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当使用的这块空间用完了，就将存活对象复制到另一块，再把已使用过的内存空间一次清理掉。
  
  * 主要用于进行新生代,实现简单、运行高效，解决了内存碎片问题。
  * 代价是可用内存缩小为原来的一半，浪费空间。
  * HotSpot 把新生代划分为一块较大的 Eden 和两块较小的 Survivor，每次分配内存只使用 Eden 和其中一块 Survivor。垃圾收集时将 Eden 和 Survivor 中仍然存活的对象一次性复制到另一块 Survivor 上，然后直接清理掉 Eden 和已用过的那块 Survivor。HotSpot 默认Eden 和 Survivor 的大小比例是 8:1，即每次新生代中可用空间为整个新生代的 90%。  
  
  当Survivor空间不足以容纳一次MinorGC之后的存活的对象时，就需要依赖其他内存区域（老年代）进行空间分配担保。
  
* 标记-整理算法

  标记-复制算法在对象存活率高时要进行较多复制操作，效率低。如果不想浪费空间，就需要有额外空间分配担保，应对被使用内存中所有对象都存活的极端情况，所以老年代一般不使用此算法。老年代使用标记-整理算法，标记过程与标记-清除算法一样，但不直接清理可回收对象，而是让所有存活对象都向内存空间一端移动，然后清理掉边界以外的内存。
  
  * 标记-清除与标记-整理的差异在于前者是一种非移动式算法而后者是移动式的。如果移动存活对象，
  
  * 尤其是在老年代这种每次回收都有大量对象存活的区域，是一种极为负重的操作，而且移动必须全程暂停用户线程。如果不移动对象就会导致空间碎片问题，只能依赖更复杂的内存分配器和访问器解决。  
  
* 分代-收集算法

  分代收集算法是现在普遍采用的垃圾收集算法。

  把堆内存分为新生代和老年代。

  新生代采用复制算法，老年代采用标记清除和标记整理的算法。

  **新生代垃圾回收过程：**

  JVM垃圾回收针对的是堆（新生代，老年代），还有元空间/方法区（永久代）。

  新生代就是短期存活的对象。

  老生代就是长期存活的，经过15次回收还未被回收的新生代对象会归属于老年代对象。

  划分新生代和老年代就是为了针对不同存亡特性的对象，而采用不同的垃圾回收算法。

  Minor GC：新生代收集

  Major GC：老年代收集

  Full GC：整堆收集，收集整个Java堆和元空间的垃圾收集；

  Mixed GC：混合收集，收集整个新生代和部分老年代的垃圾收集（目前只有G1收集器可以）

  **堆中垃圾回收的过程？**
   首先堆中划分了新生代和老生代，新生代中还以8：1：1的比例划分了Eden区，From Survivor区和To Survivor区，我们简称S0和S1区。那么在实例化一个对象的时候，它是被存放在堆中的Eden区的，然后在Eden区满了的时候，就会需要进行一次GC垃圾收集，存活下来的对象保存到S0区，S1区空着，在新生代对象下一次GC时就把Eden区和S0区的存活对象复制到空着的S1区，清空Eden和S0区。S0和S1区交替使用，保证有一个是空闲的，用于复制，这样的效率很高。

  **为何需要Survivor区？**

  * 如果没有Survivor区的话，新生代对象存放区域只有一个Eden区，并且新生代对象的更新是非常频繁的，因此在Eden区和老年区之间的复制会非常频繁，也会比较频繁的触发Full GC算法，影响系统的性能。
  * 只有一个S区的话，会出现对象在内存中不连续的情况，会出现内存碎片，因此可能会出现有一个比较大的对象要放进S区时找不到足够大的连续空间，而需要提前触发Minor GC这样的情况，如果要解决内存碎片的问题就需要引入标记整理的算法，会影响整体性能。
  * 两个S区可以保证新生代区域中有一块区域的空闲的，用于复制，这样的方式效率很高。
  * （为啥设计8：1：1）统计和经验表明，90%的对象存活时间极短，每次GC会有90%的对象被回收，剩下的10%就要预留一个survivor空间去保存。

  **动态年龄判断：**

  Survivor区的对象年龄从小到大累加，当累加到X年龄时占用空间的总和大于50%，则比X年龄大的对象都要晋升到老年代。

  **JVM的空间担保机制(避免频繁进行Full GC)：**
   新生代Minor GC后剩余存活对象太多，无法放入S区，就必须把这些存活对象转移到老年代中，如果此时老年代空间也不够怎么办？

  * 每次执行Minor GC之前，JVM会检查一下老年代可用的内存空间，是否大于新生代所有对象的总大小。（因为在极端情况下，如果新生代Minor GC之后，所有对象都需要存活，就会造成新生代所有对象都要进入老年代。）
  * 如果老年代可用内存大于新生代所有对象总大小，就可以大胆发起Minor GC，因为即使所有新生代对象都存活，S区放不下，也可以转到老年代中。
  * 如果老年代可用空间小于新生代所有对象总大小，那么就去判断老年代可用空间大小是否大于之前每一次Minor GC后进入老年代的对象的平均大小。如果小于就会直接触发FullGC，如果大于，就可以冒险尝试Minor GC。但是有可能会出现新生代存活对象大小大于S空间同时也大于老年代可用空间，此时就会触发“Full GC”。如果Full GC后，老年代还是没有足够的空间来存放Minor GC后的剩余存活对象，那么就会导致内存溢出。

  **什么情况下对象会进入老年代？**

  * 躲过15次GC之后会进入老年代；

  * 动态年龄判断；

  * 老年代空间担保机制；

  * 大对象直接进入老年代；

  大对象是指需要大量连续内存空间的Java对象，比如很长的字符串或者是很大的数组或者 List集合，大对象在分配空间时，容易导致内存明明还有不少空间时就提前触发垃圾回收以获得足够的连续空间来存放它们，而当复制对象时，大对象又会引起高额的内存复制开销，为了避免新生代里出现那些大对象，然后屡次躲过GC而进行来回复制，此时JVM 就直接把该大对象放入老年代，而不会经过新生代。

#### 类加载机制

类加载器是指:通过一个类的全限定性类名获取该类的二进制字节流叫做类加载器;类加载器分为以下四种:

* 启动类加载器( BootStrapClassLoader) :用来加载java核心类库譬如JAVA_HOME下的jre下的lib下rt.jar,resources.jar,charsets.jar，无法被java程序直接引用;
* 扩展类加载器(Extension ClassLoader) :用来加载java的扩展库，java的虚拟机实现会提供一个扩展库目录，JAVA_HOME下的jre下的lib下的ext下的jar包，该类加载器在扩展库目录里面查找并加载java类;
* 系统类加载器(AppClassLoader) :它根据java的用户类路径来加载类，一般来说，java应用的类都是通过它来加载的;
* 自定义类加载器: 由java语言实现，继承自ClassLoader;
  * 隔离加载类
  * 修改类加载的方式
  * 扩展加载源
  * 防止源码泄漏

#### 双亲委派

当一个类加载器收到一个类加载的请求，他首先不会尝试自己去加载，而是将这个请求委派给父类加载器去加载，只有父类加载器在自己的搜索范围类查找不到给类时，子加载器才会尝试自己去加载该类;为了防止内存中出现多个相同的字节码;因为如果没有双亲委派的话，用户就可以自己定义一个java.lang.String类，那么就无法保证类的唯一性。

举例来说，比如我们自己写了一个String类，然后定义一个main方法。这个时候去运行这个代码，会发现他返回错误说在String类中找不到main方法。这个原因就是因为双亲委派模型，在我们的应用类加载器收到类加载请求时，它是先向上委派给扩展类加载器，再委派给启动类加载器去加载的，然后呢这个String类它本身是属于启动类加载器路径中rt.jar包里的核心类，并且它是没有main方法的。所以运行时就会加载这个核心类而不是我们自己编写的String类了。

#### 打破双亲委派模型

自定义类加载器。

原因：

* 隔离加载类：用于隔离服务器上不同的应用程序，将类加载到不同的应用程序中。

* 扩展加载源：用于从数据库或者网络等其他终端中加载类。

* 防止源码泄露：防止代码被篡改，可以进行编译加密，类加载时就需要自定义还原加密字节码。
